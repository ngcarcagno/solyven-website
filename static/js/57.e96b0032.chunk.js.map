{"version":3,"file":"static/js/57.e96b0032.chunk.js","mappings":"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","sources":["../node_modules/lenis/packages/core/src/maths.ts","../node_modules/lenis/packages/core/src/animate.ts","../node_modules/lenis/packages/core/src/dimensions.ts","../node_modules/lenis/packages/core/src/debounce.ts","../node_modules/lenis/packages/core/src/emitter.ts","../node_modules/lenis/packages/core/src/virtual-scroll.ts","../node_modules/lenis/packages/core/src/lenis.ts","../node_modules/lenis/package.json"],"sourcesContent":["/**\r\n * Clamp a value between a minimum and maximum value\r\n *\r\n * @param min Minimum value\r\n * @param input Value to clamp\r\n * @param max Maximum value\r\n * @returns Clamped value\r\n */\r\nexport function clamp(min: number, input: number, max: number) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n/**\r\n * Truncate a floating-point number to a specified number of decimal places\r\n *\r\n * @param value Value to truncate\r\n * @param decimals Number of decimal places to truncate to\r\n * @returns Truncated value\r\n */\r\nexport function truncate(value: number, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n/**\r\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\r\n *\r\n * @param x First value\r\n * @param y Second value\r\n * @param t Amount to interpolate (0 <= t <= 1)\r\n * @returns Interpolated value\r\n */\r\nexport function lerp(x: number, y: number, t: number) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n/**\r\n * Damp a value over time using a damping factor\r\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\r\n *\r\n * @param x Initial value\r\n * @param y Target value\r\n * @param lambda Damping factor\r\n * @param dt Time elapsed since the last update\r\n * @returns Damped value\r\n */\r\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\r\n}\r\n\r\n/**\r\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n * {@link https://anguscroll.com/just/just-modulo}\r\n *\r\n * @param n Dividend\r\n * @param d Divisor\r\n * @returns Modulo\r\n */\r\nexport function modulo(n: number, d: number) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\n/**\r\n * Dimensions class to handle the size of the content and wrapper\r\n *\r\n * @example\r\n * const dimensions = new Dimensions(wrapper, content)\r\n * dimensions.on('resize', (e) => {\r\n *   console.log(e.width, e.height)\r\n * })\r\n */\r\nexport class Dimensions {\r\n  width = 0\r\n  height = 0\r\n  scrollHeight = 0\r\n  scrollWidth = 0\r\n\r\n  // These are instanciated in the constructor as they need information from the options\r\n  private debouncedResize?: (...args: unknown[]) => void\r\n  private wrapperResizeObserver?: ResizeObserver\r\n  private contentResizeObserver?: ResizeObserver\r\n\r\n  constructor(\r\n    private wrapper: HTMLElement | Window | Element,\r\n    private content: HTMLElement | Element,\r\n    { autoResize = true, debounce: debounceValue = 250 } = {}\r\n  ) {\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper instanceof Window) {\r\n        window.addEventListener('resize', this.debouncedResize, false)\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n\r\n    if (this.wrapper === window && this.debouncedResize) {\r\n      window.removeEventListener('resize', this.debouncedResize, false)\r\n    }\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper instanceof Window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce<CB extends (...args: any[]) => void>(\r\n  callback: CB,\r\n  delay: number\r\n) {\r\n  let timer: number | undefined\r\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      timer = undefined\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","/**\r\n * Emitter class to handle events\r\n * @example\r\n * const emitter = new Emitter()\r\n * emitter.on('event', (data) => {\r\n *   console.log(data)\r\n * })\r\n * emitter.emit('event', 'data')\r\n */\r\nexport class Emitter {\r\n  private events: Record<\r\n    string,\r\n    Array<(...args: unknown[]) => void> | undefined\r\n  > = {}\r\n\r\n  /**\r\n   * Emit an event with the given data\r\n   * @param event Event name\r\n   * @param args Data to pass to the event handlers\r\n   */\r\n  emit(event: string, ...args: unknown[]) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i]?.(...args)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a callback to the event\r\n   * @param event Event name\r\n   * @param cb Callback function\r\n   * @returns Unsubscribe function\r\n   */\r\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback from the event\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  /**\r\n   * Remove all event listeners and clean up\r\n   */\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private __rafID: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = orientation === 'horizontal' ? 'both' : 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n\n      const overflow = getComputedStyle(this.rootElement)[\n        property as keyof CSSStyleDeclaration\n      ] as string\n\n      if (['hidden', 'clip'].includes(overflow)) {\n        this.internalStop()\n      } else {\n        this.internalStart()\n      }\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n    const anchor = path.find(\n      (node) =>\n        node instanceof HTMLAnchorElement &&\n        (node.getAttribute('href')?.startsWith('#') ||\n          node.getAttribute('href')?.startsWith('/#') ||\n          node.getAttribute('href')?.startsWith('./#'))\n    ) as HTMLAnchorElement | undefined\n    if (anchor) {\n      const id = anchor.getAttribute('href')\n\n      if (id) {\n        const options =\n          typeof this.options.anchors === 'object' && this.options.anchors\n            ? this.options.anchors\n            : undefined\n\n        let target: number | string = `#${id.split('#')[1]}`\n        if (['#', '/#', './#', '#top', '/#top', './#top'].includes(id)) {\n          target = 0\n        }\n\n        this.scrollTo(target, options)\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        this.limit > 0 &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n            // immediate: !hasTouchInertia,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = this.options.lerp,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n","{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.11\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:dev\": \"npm publish --tag dev\",\n    \"publish:main\": \"npm publish\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n"],"names":["clamp","min","input","max","Math","Animate","constructor","_defineProperty","advance","deltaTime","_this$onUpdate","this","isRunning","completed","duration","easing","currentTime","linearProgress","easedProgress","value","from","to","lerp","x","y","lambda","t","exp","damp","round","stop","onUpdate","call","fromTo","_ref","lerp2","onStart","Dimensions","wrapper","content","autoResize","debounce","debounceValue","arguments","length","undefined","onWrapperResize","onContentResize","Window","width","window","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","debouncedResize","callback","delay","timer","_len","args","Array","_key","context","clearTimeout","setTimeout","apply","resize","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","_this$wrapperResizeOb","_this$contentResizeOb","disconnect","removeEventListener","limit","Emitter","emit","event","callbacks","events","_len2","_key2","i","_callbacks$i","on","cb","_this$events$event","push","_this$events$event2","filter","off","_this$events$event3","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","clientX","clientY","targetTouches","touchStart","lastDelta","emitter","deltaX","deltaY","deltaMode","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","defaultEasing","pow","Lenis","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","virtualScroll","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","e","CustomEvent","isScrolling","stopPropagation","dispatchEvent","bubbles","detail","lenisScrollEnd","propertyName","includes","property","isHorizontal","overflow","getComputedStyle","rootElement","internalStop","internalStart","anchor","composedPath","find","node","_node$getAttribute","_node$getAttribute2","_node$getAttribute3","HTMLAnchorElement","getAttribute","startsWith","id","target","concat","split","scrollTo","button","reset","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isTouching","isClickOrTap","isStopped","isLocked","isUnknownGesture","slice","indexOf","_node$hasAttribute","_node$hasAttribute2","_node$hasAttribute3","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","animate","delta","abs","animatedScroll","isSyncTouch","hasTouchInertia","sign","velocity","targetScroll","_objectSpread","programmatic","_resetVelocityTimeout","_preventNextNativeScrollEvent","lastScroll","actualScroll","lastVelocity","direction","time","__rafID","requestAnimationFrame","raf","lenisVersion","dimensions","updateClassName","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","onTransitionEnd","cleanUpClassName","cancelAnimationFrame","setScroll","scroll","left","behavior","top","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","userData","_target","querySelector","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","dispatchScrollendEvent","_ref2","_node$_lenis","_cache$time","Date","now","cache","_lenis","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","computedStyle","overflowXString","overflowX","overflowYString","overflowY","maxScroll","hasOverflow","isScrollable","scrollLeft","scrollTop","_wrapper$scrollX","_wrapper$scrollY","scrollX","scrollY","n","d","progress","_isScrolling","_isStopped","_isLocked","isSmooth","className","trim","replace"],"sourceRoot":""}